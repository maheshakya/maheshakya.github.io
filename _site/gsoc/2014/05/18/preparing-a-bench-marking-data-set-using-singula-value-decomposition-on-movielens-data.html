<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="/stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="/stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="/stylesheets/print.css" media="print" />

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <link rel="alternate" type="application/rss+xml" title="RSS" href="/feed.xml">

    <title> Singular value decomposition to create a bench marking data set from MovieLens data </title>
    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-50627295-1', 'maheshakya.github.io');
  ga('send', 'pageview');

</script>
  </head>


  <body>
  <script>
      window.fbAsyncInit = function() {
        FB.init({
          appId      : '282511005256163',
          xfbml      : true,
          version    : 'v2.0'
        });
      };

      (function(d, s, id){
         var js, fjs = d.getElementsByTagName(s)[0];
         if (d.getElementById(id)) {return;}
         js = d.createElement(s); js.id = id;
         js.src = "//connect.facebook.net/en_US/sdk.js";
         fjs.parentNode.insertBefore(js, fjs);
       }(document, 'script', 'facebook-jssdk'));
    </script>
    <header>
      <div class="inner">
        <h1 > <a href="/" style="color:white"> Espy Yonder </a></h1>  
        <h2>Maheshakyas' personal blog</h2>
        
        <a href="https://github.com/maheshakya" class="button"><small>View my profile on</small>GitHub</a>

      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
          
          <h1>Singular value decomposition to create a bench marking data set from MovieLens data</h1>
<p class="meta">18 May 2014</p>
<script type="text/javascript"
    src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<p>This is the second article on my Google Summer of Code project and this follows from my <a href="/gsoc/2014/05/04/approximate-nearest-neighbor-search-using-lsh.html">previous post</a> about the description about my project: Approximate nearest neighbor search using Locality sensitive hashing. Here, I will elaborate how I created my data set for prototyping, evaluating and bench marking purposes in the project. I have used <a href="http://en.wikipedia.org/wiki/Singular_value_decomposition">Singular value decomposition</a> on the <a href="http://grouplens.org/datasets/movielens/">MovieLens 1M</a> data to create this sample data set.</p>

<h2>MovieLens 1M data</h2>

<p><a href="http://grouplens.org/">GroupLens Research</a> is and organization publishes research articles in conferences and journals primarily in the field of computer science, but also in other fields including psychology, sociology, and medicine. It has collected and made available rating data sets from the <a href="http://movielens.org">MovieLens</a> web site. The data sets were collected over various periods of time, depending on the size of the set.</p>

<p>MovieLens 1M data set contains 1,000,209 anonymous ratings of approximately 3,900 movies made by 6,040 MovieLens users who joined MovieLens in 2000. After extracting the compressed content, there will be following files at your hand:</p>

<ul>
<li>ratings.dat : Contains user IDs, movie IDs, ratings on 5 star scale and time stamp.</li>
<li>movies.dat  : Contains movie IDs, titles and genres.</li>
<li>users.dat   : Contains user IDs, genders, ages, ocupations and zip-codes.</li>
</ul>

<p>More information about this can be found in the <a href="http://files.grouplens.org/datasets/movielens/ml-1m-README.txt">README</a>. </p>

<h2>A brief explanation about singular value decomposition and its&#39; role in machine learning</h2>

<p>Singular value decomposition is a matrix factorization method. The general equation can be expressed as follows.</p>

<p>$$X = USV^T$$</p>

<p>Suppose \(X\) has \(n\) rows and \(d\) columns. \(U\) is a matrix whose dimensions are \(n \times n\), \(V\) is another matrix whose dimensions are \(d \times d\), and \(S\) is a matrix whose dimensions are \(n \times d\), the same dimensions as \(X\). 
In addition, \(U^T U = I _ n\) and \(V^T V = I _ d\)</p>

<p>You can read and understand more about this decomposition method and how it work from this <a href="http://en.wikibooks.org/wiki/Data_Mining_Algorithms_In_R/Dimensionality_Reduction/Singular_Value_Decomposition">article</a>.</p>

<h3>What is the significance of the SVD(Singular Value Decomposition) in machine learning and what does it have to do with MovieLens data?</h3>

<p>We can represent each movie from a dimension and each user corresponds to a data point in this high dimensional space. But we are not able to visualize more than three dimensions. This data can be represented by a matrix(The \(X\) in the above equation). A sample depiction of the matrix may look as follows. 
<img src="https://docs.google.com/drawings/d/1oBQ7iNf-c6GCYBvalyM7HXlcscX1ATz9lQsxzpHdCyQ/pub?w=960&amp;h=720" alt="user_movie_matrix">
Because number of ratings for a movie by users is significantly low when considered with the number of users, this matrix contains a large number of empty entries. Therefore this matrix will be a very sparse matrix. Hence, approximating this matrix with a lower rank matrix is a worthwhile attempt.</p>

<p>Consider the following scenario:</p>

<p>If every user who likes &quot;movie X&quot; also likes &quot;movie Y&quot;, then it is possible to group them together to form an agglomerative movie or feature. After forming new features in that way, two users can be compared by analyzing their ratings for different features rather than for individual movies.</p>

<p>In the same way different users may rate same movies similarly. So there can different types of similarities among user preferences.</p>

<p>According to this factorization method (you might want to read more about SVD at this point from the reference I have provided earlier) the matrix \(S\) is a diagonal matrix containing the singular values of the matrix \(X\). The number of singular values is exactly equal to the rank of the matrix \(X\). The rank of a matrix is the number of linearly independent rows or columns in the matrix. We know that two vectors are linearly independent if they cannot be written as the sum or scalar multiple of any other vectors in that vector space. You can notice that this linear independence somehow captures the notion of a feature or agglomerative item which we try to generate from in this approach. According to the above scenario, if every user who liked &quot;Movie X&quot; also liked &quot;Movie Y&quot;, then those two movie vectors would be linearly dependent and would only contribute one to the rank.</p>

<p>So how are we to get rid of this redundant data. We can compare movies if most users who like one also like the other. In order to do that, we will keep the largest k singular values in \(S\). This will give us the best rank-k approximation to X. </p>

<p>So the entire procedure can be boiled down to following three steps:</p>

<ol>
<li>Compute the SVD: \(X = U S V^T\).</li>
<li>Form the matrix \(S&#39;\) by keeping the k largest singular values and setting the others to zero.</li>
<li>Form the matrix \(X _ lr\) by \(X _ lr = U S&#39; V^T\).</li>
</ol>

<h2>Implementation</h2>

<p>To perform SVD on MovieLens data set and recompose the matrix with a lower rank, I used scipy sparse matrix, numpy and pandas. It has been done in following steps.</p>

<p>1)  Import required packages.</p>

<div class="highlight"><pre><code class="python"><span class="kn">import</span> <span class="nn">pandas</span> <span class="kn">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.sparse.linalg</span> <span class="kn">import</span> <span class="n">svds</span>
<span class="kn">import</span> <span class="nn">pickle</span>
</code></pre></div>

<p>2)  Load data set into a pandas data frame.</p>

<div class="highlight"><pre><code class="python"><span class="n">data_file</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_table</span><span class="p">(</span><span class="s">r&#39;ratings.dat&#39;</span><span class="p">,</span> <span class="n">sep</span> <span class="o">=</span> <span class="s">&#39;::&#39;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
</code></pre></div>

<p>Here,I have assumed that the <code>ratings.dat</code> file from MovieLens 1M data will be in the working directory. Only reason I am using pandas data frame is its&#39; convenience of usage. You can directly open the file and proceed. But then you will have to change following steps to adapt to that method.</p>

<p>3)  Extract required meta information from the data set.</p>

<div class="highlight"><pre><code class="python"><span class="n">users</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">data_file</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">movies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">data_file</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
 
<span class="n">number_of_rows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">users</span><span class="p">)</span>
<span class="n">number_of_columns</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">movies</span><span class="p">)</span>

<span class="n">movie_indices</span><span class="p">,</span> <span class="n">user_indices</span> <span class="o">=</span> <span class="p">{},</span> <span class="p">{}</span>
 
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">movies</span><span class="p">)):</span>
    <span class="n">movie_indices</span><span class="p">[</span><span class="n">movies</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">i</span>
    
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">users</span><span class="p">)):</span>
    <span class="n">user_indices</span><span class="p">[</span><span class="n">users</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">i</span>
</code></pre></div>

<p>As the user IDs and movie IDs are not continueous integers(there are missing numbers inbetween), a proper mapping is required. It will be used when inserting data into the matrix. At this point, you can delete the loaded data frame in order to save memory. But it is optional.</p>

<p>4)  Creating the sparse matrix and inserting data.</p>

<div class="highlight"><pre><code class="python"><span class="c">#scipy sparse matrix to store the 1M matrix</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">lil_matrix</span><span class="p">((</span><span class="n">number_of_rows</span><span class="p">,</span> <span class="n">number_of_columns</span><span class="p">))</span>

<span class="c">#adds data into the sparse matrix</span>
<span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">data_file</span><span class="o">.</span><span class="n">values</span><span class="p">:</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">i</span> <span class="p">,</span> <span class="n">r</span> <span class="p">,</span> <span class="n">gona</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span><span class="n">line</span><span class="p">)</span>
    <span class="n">V</span><span class="p">[</span><span class="n">user_indices</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">movie_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">r</span>
</code></pre></div>

<p>You can save sparse matrix <code>V</code> using <code>pickle</code> if you are willing to use it later. </p>

<div class="highlight"><pre><code class="python"><span class="c">#as these operations consume a lot of time, it&#39;s better to save processed data </span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">&#39;movielens_1M.pickle&#39;</span><span class="p">,</span> <span class="s">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">handle</span><span class="p">:</span>
    <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">handle</span><span class="p">)</span>
</code></pre></div>

<p>5)  Perform SVD.</p>

<div class="highlight"><pre><code class="python"><span class="c">#as these operations consume a lot of time, it&#39;s better to save processed data </span>
<span class="c">#gets SVD components from 10M matrix</span>
<span class="n">u</span><span class="p">,</span><span class="n">s</span><span class="p">,</span> <span class="n">vt</span> <span class="o">=</span> <span class="n">svds</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">500</span><span class="p">)</span>
 
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">&#39;movielens_1M_svd_u.pickle&#39;</span><span class="p">,</span> <span class="s">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">handle</span><span class="p">:</span>
    <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">handle</span><span class="p">)</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">&#39;movielens_1M_svd_s.pickle&#39;</span><span class="p">,</span> <span class="s">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">handle</span><span class="p">:</span>
    <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">handle</span><span class="p">)</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">&#39;movielens_1M_svd_vt.pickle&#39;</span><span class="p">,</span> <span class="s">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">handle</span><span class="p">:</span>
    <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">vt</span><span class="p">,</span> <span class="n">handle</span><span class="p">)</span>
</code></pre></div>

<p>The <code>svds</code> method performs the SVD. Parameter <code>k</code> is the number of singular values we want to retain. Here also I have save the intermediate data using <code>pickle</code></p>

<p>After this decomposition you will get <code>u</code>, <code>s</code> and <code>vt</code>. They have (<code>number of users</code>, <code>k</code>), (<code>k</code>, ) and (<code>k</code>, <code>number of movies</code>) shapes respectively.</p>

<p>6)  Recomposing the lower rank matrix.</p>

<p>As <code>s</code> is a vector, we need to create a diagonal matrix form that with the diagonal containing the values of that vector. It is done as follows:</p>

<div class="highlight"><pre><code class="python"><span class="n">s_diag_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
    <span class="n">s_diag_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</code></pre></div>

<p>This will create a diagonal matrix. After that, all you have to do is get the matrix product of <code>u</code>, <code>s_diag_matix</code> and <code>vt</code> in that order.</p>

<div class="highlight"><pre><code class="python"><span class="n">X_lr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">s_diag_matrix</span><span class="p">),</span> <span class="n">vt</span><span class="p">)</span>
</code></pre></div>

<p>Now we have the lower rank approximation for \(X\) as \(X _ lr = U S&#39; V^T\). Now this matrix can be used as a bench marking data set for the application.</p>

<h2>References</h2>

<ol>
<li>Dimensionality Reduction and the Singular Value Decomposition, Available[online]: <a href="http://www.cs.carleton.edu/cs_comps/0607/recommend/recommender/svd.html">http://www.cs.carleton.edu/cs_comps/0607/recommend/recommender/svd.html</a></li>
<li>Data Mining Algorithms In R/Dimensionality Reduction/Singular Value Decomposition, Available[online]: <a href="http://en.wikibooks.org/wiki/Data_Mining_Algorithms_In_R/Dimensionality_Reduction/Singular_Value_Decomposition">http://en.wikibooks.org/wiki/Data<em>Mining</em>Algorithms<em>In</em>R/Dimensionality<em>Reduction/Singular</em>Value_Decomposition</a></li>
</ol>


If you have any questions or comments, please post them below. If
you liked this post, you can
<a href="https://twitter.com/intent/tweet?url=http://maheshakya.github.io//gsoc/2014/05/18/preparing-a-bench-marking-data-set-using-singula-value-decomposition-on-movielens-data.html&text=Singular value decomposition to create a bench marking data set from MovieLens data&via=Wmaheshakya" 
   target="_blank">
  share it with your followers.</a> 
And don't forget to  
<a href="https://twitter.com/Wmaheshakya">
  follow me on Twitter</a>!
  <!-- Add Disqus comments. -->
  <div id="disqus_thread"></div>
  <script type="text/javascript">
      /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
      var disqus_shortname = 'maheshakya'; // required: replace example with your forum shortname

      /* * * DON'T EDIT BELOW THIS LINE * * */
      (function() {
          var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
          dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>



          
        </section>

        <aside id="sidebar">
          <a href="/pages/about" class="button">about me</a>
          <a href="/feed.xml" class="button">RSS feed</a>
          <a href="https://github.com/maheshakya/maheshakya.github.io/archive/master.zip" class="button">
            <small>Download this blog</small>
            .zip file
          </a>

          <div class="fb-like" data-href="/gsoc/2014/05/18/preparing-a-bench-marking-data-set-using-singula-value-decomposition-on-movielens-data.html" data-layout="button_count" data-action="like" data-show-faces="true" data-share="true"></div>


        </aside>
      </div>
    </div>

    

  </body>
</html>