<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta charset="utf-8">
    
    <meta name="description" content="">
    <title> LSH Forest with sorted arrays and binary search › Espy Yonder</title>
    <link rel="canonical" href="//gsoc/2014/06/01/lsh-forest-with-sorted-arrays-and-binary-search.html">
    <link href="/main.css" rel="stylesheet" type="text/css">
    <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,600,700,200italic,300italic,400italic,600italic,700italic' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Gentium+Basic:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css' rel='stylesheet' type='text/css'>
    <link rel="alternate" type="application/rss+xml" title="Espy Yonder &raquo; Feed" href="/feed.xml">
    <script src="//maheshakya.disqus.com/embed.js" async></script>
    
    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-50627295-1', 'maheshakya.github.io');
  ga('send', 'pageview');

</script>
  </head>
  <body>
    <header>
      
      <nav>
        <ul>
          <li><a href="/">Home</a></li><li><a href="/archive.html">Archive</a></li><li><a href="/pages/about/index.html">About me</a></li>
        </ul>
      </nav>
    </header>
    <div><h1><a href="/">Espy Yonder</a></h1></div>
    <div>maheshakyas' personal website</div>
    <article>
      <header>
        <h2><a href="/gsoc/2014/06/01/lsh-forest-with-sorted-arrays-and-binary-search.html">LSH Forest with sorted arrays and binary search</a></h2>
        <p><time datetime="2014-06-01T00:00:00+05:30">Jun 1, 2014</time> • gsoc</p>
      </header>
      <div>
<script type="text/javascript"
    src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<p>More on GSoC with <a href="http://scikit-learn.org/stable/index.html">scikit-learn</a>! LSH forest is a promising, novel and alternative method introduced in order to alleviate the drawbacks from which vanilla LSH suffers. I assume you have a passable idea of what LSH means. If not, I suggest you to refer to this: <a href="http://en.wikipedia.org/wiki/Locality-sensitive_hashing">Locality-sensitive hashing</a>. LSH forest has a theoretical guarantee of its’ suggested improvements. For more information, refer to the published paper: <a href="http://ilpubs.stanford.edu:8090/678/1/2005-14.pdf">LSH Forest: Self-Tuning Indexes for Similarity Search</a></p>

<p>In general, the data structure used to implement LSH forest is a <a href="http://en.wikipedia.org/wiki/Trie">prefix tree</a>(trie). In this article, I will elaborate how to implement it with sorted arrays and binary search. This will reduce the complexity involved with a separate data structure(such as a tree). You can see the complete implementation in this <a href="https://gist.github.com/maheshakya/b22f640f67d7b574fd56">gist</a>.</p>

<h2 id="how-it-is-done">How it is done</h2>

<p>This implementation follows every design aspect suggested in the LSH forest paper except the data structure. LSH_forest is a class which has the initialization method as follows:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_label_length</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span> <span class="n">number_of_trees</span> <span class="o">=</span> <span class="mi">5</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_label_length</span> <span class="o">=</span> <span class="n">max_label_length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">number_of_trees</span> <span class="o">=</span> <span class="n">number_of_trees</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></code></pre></div>

<p><code>numpy</code> has been used and imported as <code>np</code>. Variable names are as same as the names in the paper. The length of the hash is a fixed value. This value will be a small integer for almost all the applications.</p>

<p>In a normal LSH based nearest neighbor search, there are two main operations.</p>

<ol>
  <li>Building index</li>
  <li>Queries</li>
</ol>

<h3 id="building-index">Building index</h3>

<p>First stage of building index is hashing the data point in the data set passed into the function. <a href="http://en.wikipedia.org/wiki/Locality-sensitive_hashing#Random_projection">Random projection</a> has been used as the hashing algorithm(It belongs to LSH family). In order to perform random projection, a set of random hyper-planes is required with the shape of \(expected Hash Size \times dimension Of The Data Vector\). It is done by the following function.</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">_get_random_hyperplanes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hash_size</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">dim</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">        Generates hyperplanes from standard normal distribution  and return </span>
<span class="sd">        it as a 2D numpy array. This is g(p,x) for a particular tree.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">hash_size</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span></code></pre></div>

<p>Then, the random projection is performed. It is a simple operation as all it needs to do is get the dot product of the generated hyper-planes and the data vectors. Then it will create a binary string taking the sign of the hash into account:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_point</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">hash_function</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does hash on the data point with the provided hash_function: g(p,x).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">projections</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">hash_function</span><span class="p">,</span> <span class="n">input_point</span><span class="p">)</span>             
        <span class="k">return</span> <span class="s">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s">&#39;1&#39;</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="s">&#39;0&#39;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">projections</span><span class="p">])</span></code></pre></div>

<p>After this a tree(a figurative tree) is build using by sorting those binary hashes. At this point, original indices are retained because it will be only way to refer to the original vectors from now on. It is done as follows:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">_create_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_array</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">hash_function</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Builds a single tree (in this case creates a sorted array of </span>
<span class="sd">        binary hashes).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">number_of_points</span> <span class="o">=</span> <span class="n">input_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">binary_hashes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_of_points</span><span class="p">):</span>
            <span class="n">binary_hashes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">(</span><span class="n">input_array</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">hash_function</span><span class="p">))</span>
        
        <span class="n">binary_hashes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">binary_hashes</span><span class="p">)</span>
        <span class="n">o_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">binary_hashes</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">o_i</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">binary_hashes</span><span class="p">)</span></code></pre></div>

<p>This is the process which has to be done a single tree. But there are multiple number of trees. So this has to be done for each tree. The above function is called for each tree with the corresponding hash function which is \(g(p)\). Then hash functions, trees and original indices are stored as <code>numpy</code> arrays.</p>

<h3 id="queries">Queries</h3>

<p>This is the tricky part of this implementation. All the tree operations indicated in the paper have to be converted into range queries in order to work with sorted arrays and binary search. I will move step by step about how binary search has been used in this application.</p>

<p>The first objective is: given a sort array of binary hashes, a binary query and a hash value <code>h</code>, retrieve an array of indices where the most significant <code>h</code> bits of the entries are as same as the most significant <code>h</code> bits of the query. In order to achieve this, I have re-implemented the <code>bisect</code> functions(which comes by default with Python) with a little essential modification.</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">bisect_left</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="n">lo</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">hi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">lo</span> <span class="o">&lt;</span> <span class="n">hi</span><span class="p">:</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">lo</span><span class="o">+</span><span class="n">hi</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
        <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">:</span>
            <span class="n">lo</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">hi</span> <span class="o">=</span> <span class="n">mid</span>
    <span class="k">return</span> <span class="n">lo</span>
            
<span class="k">def</span> <span class="nf">bisect_right</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="n">lo</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">hi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">lo</span> <span class="o">&lt;</span> <span class="n">hi</span><span class="p">:</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">lo</span><span class="o">+</span><span class="n">hi</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">a</span><span class="p">[</span><span class="n">mid</span><span class="p">][:</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span><span class="o">==</span><span class="n">x</span><span class="p">:</span>
            <span class="n">hi</span> <span class="o">=</span> <span class="n">mid</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lo</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">lo</span>

<span class="c">#function which accepts an sorted array of bit strings, a query string</span>
<span class="c">#This returns an array containing all indices which share the first h bits of the query</span>
<span class="k">def</span> <span class="nf">simpleFunctionBisectReImplemented</span><span class="p">(</span><span class="n">sorted_array</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">h</span><span class="p">):</span>
    <span class="n">left_index</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">sorted_array</span><span class="p">,</span> <span class="n">item</span><span class="p">[:</span><span class="n">h</span><span class="p">])</span>
    <span class="n">right_index</span> <span class="o">=</span> <span class="n">bisect_right</span><span class="p">(</span><span class="n">sorted_array</span><span class="p">,</span> <span class="n">item</span><span class="p">[:</span><span class="n">h</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">left_index</span><span class="p">,</span> <span class="n">right_index</span><span class="p">)</span></code></pre></div>

<p>Here I have considered a minor aspect about slicing and <code>startswith</code> in Python string. In place of <code>a[mid][:len(x)]==x</code>, I could have used <code>startswith</code> in-built function. But after a little research, it became obvious why the latter is not suitable here. <code>startswith</code> works efficiently with very long strings, but slicing has been optimized from C level for efficiency for small strings. In this application, hash strings do not have a requirement to be very long. You can read more about this from this <a href="http://stackoverflow.com/questions/13270888/why-is-startswith-slower-than-slicing">question</a>.</p>

<p>The time complexity of this method is as any binary search. The number of entries <code>n</code> is the length of the array of sorted binary hashes. There are two searches in this method, but after performing it, the overall complexity will be \(O(log n)\). (You can do the math and confirm)</p>

<p>There is another binary search. It is to find the longest prefix match for a binary query string in a sorted array of binary hashes.</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">find_longest_prefix_match</span><span class="p">(</span><span class="n">bit_string_list</span><span class="p">,</span> <span class="n">query</span><span class="p">):</span>
    <span class="n">hi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
    <span class="n">lo</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">simpleFunctionBisectReImplemented</span><span class="p">(</span><span class="n">bit_string_list</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">hi</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">hi</span>
    
    <span class="k">while</span> <span class="n">lo</span> <span class="o">&lt;</span> <span class="n">hi</span><span class="p">:</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">lo</span><span class="o">+</span><span class="n">hi</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>        
        <span class="n">k</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">simpleFunctionBisectReImplemented</span><span class="p">(</span><span class="n">bit_string_list</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">mid</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">lo</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">mid</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">hi</span> <span class="o">=</span> <span class="n">mid</span>            
        
    <span class="k">return</span> <span class="n">res</span></code></pre></div>

<p>Time complexity of this operation is a little trickier. Binary searches on two different parameters are involved in this. The outer binary search corresponds to the length of the query string: say <code>v</code> and the inner binary search corresponds to length of the sorted array of binary hashes: say <code>n</code>. The it has a complexity of \(logv \times logn\). So it will be approximately \(O(logn^K)\) where \(K=logv\).</p>

<p>That is all the basic setting required to implement LSH forest with sorted arrays and binary search. Now we can move on to the actual implementation of queries as indicated in the paper. There are two main phases described to perform queries.</p>

<ol>
  <li>Descending phase.</li>
  <li>Synchronous ascending phase.</li>
</ol>

<p>In the descending phase, the longest matching hash length for a particular query is retrieved from all the tree. This step is quite straightforward as all is does is using the above described longest prefix match function on each tree. From this <code>max_depth</code> (<code>x</code> in the paper) is found.</p>

<p>The query function accept a value for \(c\) (refer to the paper) as well. This determines the number of candidates returned from the function. This is \(M\) which is equal to \(c \times numberOfTrees\). In asynchronous ascend phase, starting from <code>x</code>, every matching <code>x</code> long entry from each tree is collected(in a loop). Then <code>x</code> is decreased by one. Same is done repeatedly for each tree until the required number of candidates are retrieved. During the process, the length of candidate list may grow greater than required number of candidates. But the search does not end until the following condition is sufficed(As described in the synchronous ascend algorithm in the paper).</p>

<p>condition: \(x&gt;0\) and \((lenth(candidates) &gt; c \) or  \(length(unique(candidates)) &gt; m)\)</p>

<p>\(M » m\) where \(m\) is the actual number of neighbors required. So after selecting the candidates, a true distance measure will be used to determine the actual neighbors. This will be done later as the project proceeds. The current implementation will be used to perform the tasks in the <a href="/gsoc/2014/05/25/performance-evaluation-of-approximate-nearest-neighbor-search-implementations---part-1.html">evaluation criteria</a> that I have discussed in my earlier post.</p>

<p>In my next post I will illustrate how the various versions of LSH forest performs and a comparison with other ANN implementations.</p>

<h3 id="acronyms">Acronyms</h3>

<ol>
  <li>LSH : Locality Sensitive Hashing</li>
</ol>



If you have any questions or comments, please post them below. If
you liked this post, you can
<a href="https://twitter.com/intent/tweet?url=//gsoc/2014/06/01/lsh-forest-with-sorted-arrays-and-binary-search.html&text=LSH Forest with sorted arrays and binary search&via=Wmaheshakya" 
   target="_blank">
  share it with your followers.</a> 


      </div>
      
      
      <div id="disqus_thread"></div>
      <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
      
    </article>

    <footer>
      <span><a href="/">pruthuvi maheshakya wijewardena</a></span>
      <span><a href="https://github.com/maheshakya"><i class="fa fa-github-square"></i></a><a href="https://twitter.com/Wmaheshakya"><i class="fa fa-twitter-square"></i></a><a href="https://plus.google.com/u/0/+MaheshakyaWijewardena/"><i class="fa fa-google-plus-square"></i></a><a href="https://www.linkedin.com/in/maheshakya"><i class="fa fa-linkedin-square"></i></a><a href="https://www.facebook.com/pmaheshakya"><i class="fa fa-facebook-square"></i></a><a href="/feed.xml"><i class="fa fa-rss-square"></i></a></span>
      <span>&copy; 2015</span>
    </footer>
  </body>
</html>
